#!/usr/bin/awk -f
#
# Fawkss â€” The [ig]noble CSS preprocessor.
# ========================================
#
# Fawkss is a CSS preprocessor for people who dislike CSS preprocessors. It
# implements a subset of the SASS syntax while remaining relatively simple.
#
# This documentation is built using Markdown syntax, and can be parsed out by
# running `make doc` in the project root. Please check the project's README file
# for additional information.
#
# Built-in functions
# ------------------
#
# This section contains global helper functions, used across different rules, as
# defined in the next section below.
#
# > Function `lastindex` returns the index of the last occurence of a substring
# > `s` in `str`, or -1 if the substring was not found.
function lastindex(str, s) {
	match(str, ".*" s)
	return max(RSTART + RLENGTH - 1, -1)
}

# > Function `max` finds and returns greatest between two numbers.
function max(x, y) {
	return (x > y) ? x : y
}

# > Function `trim` removes characters (whitespace by default) off both ends of
# > the string passed and returns the modified string.
function trim(str, ch) {
	ch = (ch != "") ? ch : ":space:"
	match(str, "[" ch "]*[^[" ch "]]+[" ch "]*")

	return substr(str, RSTART, RLENGTH)
}

# > Function `basename` strips the directory name from file paths and returns
# > the resulting file name.
function basename(path) {
	match(path, "[^/]+$")
	return substr(path, RSTART, RLENGTH)
}

# > Function `dirname` strips the last component from a path and returns the
# > resulting path.
function dirname(path) {
	match(path, "^.+/")
	return substr(path, RSTART, RLENGTH)
}

# > Function `file_exists` checks if file pointed to by `filename` exists, and
# > returns `1` if true, `0` if false.
function file_exists(filename) {
	return (system("[ -e '" filename "' ]") == 0) ? 1 : 0;
}

# Global declarations
# -------------------
#
# This block contains logic for initializing global variables used across Fawkss.

BEGIN {
	# Error messages used across Fawkss.
	errors["variable-undeclared"] = "ERROR: Use of undeclared variable '%s' on line %d\n"
	errors["import-cyclic"]       = "ERROR: Cyclic import of file '%s' in file '%s', line %d\n"
	errors["import-not-found"]    = "ERROR: Import file '%s' not found, defined in '%s' on line %d\n"

	# Rule definitions.
	rules["comment"]           = "[ ]*//.*$"
	rules["comment-exception"] = "['\"][^//]*//[^'\"]*['\"]"

	rules["variable-name"]   = "\\$[a-zA-Z0-9_-]+"
	rules["variable-define"] = "^[ ]*" rules["variable-name"] "[ ]*:"

	rules["import-path"]     = "['\"][^'\".]+(.scss)?[ ]*['\"]"
	rules["import-define"]   = "[ ]*@import[ ]+" rules["import-path"] "[ ]*;"
	rules["import-variants"] = "%s%s.scss,%s_%s.scss,%s%s,%s_%s"
}

# Import stack initialization
# ----------------------------
#
# This block initializes the import stack with the current filename, and reads
# from the top line-by-line until the stack is exhausted. Import declarations
# switch the read context by pushing to the stack, and are popped when the read
# operation reaches EOF or any error.

{
	# File import stack.
	imports["length"] = 0
	imports[imports["length"]] = FILENAME

	# Read from import file stack line-by-line until stack is exhausted.
	while (imports["length"] >= 0) {
		while ((getline < imports[imports["length"]]) > 0) {

# Rule definitions
# ----------------
#
# This block contains definitions for line manipulation rules used across Fawkss.
# Rules may or may not be exclusive, i.e. the effects of one rule may cascade to
# subsequent rules for the same line.
#
# > Match import declarations, for example:
# >
# >     @import "partials/colors";
# >
# > The above declaration may match file `_colors.scss` or `colors.scss` in the
# > `partials` directory (which should exist on the same level as the calling
# > file). Imports can be nested (i.e. imported files may in turn import other
# > files), and cyclic dependancies will return a fatal error.
if ($0 ~ rules["import-define"]) {
	# Extract path part from import declaration.
	match($0, rules["import-path"])
	path = substr($0, RSTART + 1, RLENGTH - 2)

	# Extract file and directory name parts from path, and append root directory
	# path for current file to directory part.
	dir = dirname(imports[imports["length"]]) dirname(path)
	file = basename(path)

	# Check filename against all potential filename variations.
	exists = 0
	split(rules["import-variants"], variants, ",")

	for (v in variants) {
		filename = sprintf(variants[v], dir, file)
		if (file_exists(filename)) {
			exists = 1
			break
		}
	}

	# Return error if import file was not found.
	if (!exists) {
		printf errors["import-not-found"], path, imports[imports["length"]], FNR | "cat >&2"
		exit 1
	}

	# Check for cyclic imports.
	if (filename in processed) {
		printf errors["import-cyclic"], filename, imports[imports["length"]], FNR | "cat >&2"
		exit 1
	}

	# Add filename to list of processed files.
	processed[filename] = 1

	# Push filename to stack of processed files and continue to next line.
	imports["length"] += 1
	imports[imports["length"]] = filename
	continue
}

# > Match variable declarations, for example:
# >
# >     $varname: "value";
# >
# > Only one variable declaration can appear on a single line. Redeclaring a
# > variable overrides the value set for that variable.
if ($0 ~ rules["variable-define"]) {
	# Split text in tokens.
	split($0, token, ":")

	# Get variable name and value.
	name = trim(substr(token[1], index(token[1], "$")))
	value = trim(substr(token[2], 0, lastindex(token[2], ";") - 1))

	# Assign variable to the global variables table.
	variables[name] = value
	continue
}

# > Match inline comments, for example:
# >
# >     // This is an inline comment.
# >     :root{background: white;} // Another inline comment.
# >
# > As opposed to regular CSS comments (i.e. `/* */`), inline comments are removed
# > from the processed result. Inline comments inside strings are not removed.
if ($0 ~ rules["comment"]) {
	# Initialize local variables.
	len = 0

	# Remove any special cases from the line.
	while (match($0, rules["comment-exception"])) {
		special[len += 1] = RSTART ":" substr($0, RSTART, RLENGTH)
		$0 = substr($0, 0, RSTART - 1) substr($0, RSTART + RLENGTH, length($0))
	}

	# Remove inline comments from line.
	while (match($0, rules["comment"])) {
		$0 = substr($0, 0, RSTART - 1) substr($0, RSTART + RLENGTH, length($0))
	}

	# Reinsert special cases in their predefined positions.
	for (i = len; i != 0; i--) {
		pos = substr(special[i], 0, index(special[i], ":") - 1)

		# Do not attempt to reinsert special case string if string has been
		# truncated to less the original position of the string.
		if (pos > length($0)) {
			continue
		}

		str = substr(special[i], index(special[i], ":") + 1, length(special[i]))
		$0 = substr($0, 0, pos - 1) str substr($0, pos, length($0))
	}
}

# > Match variable uses, for example:
# >
# >     :root{background: $white;}
# >
# > Where `$white` is a previously declared variable. Attempting to use a variable
# > that has not been defined yet will throw a fatal error.
if ($0 ~ rules["variable-name"]) {
	# Replace each variable use with its concrete value.
	while (match($0, rules["variable-name"])) {
		name = substr($0, RSTART, RLENGTH)

		# Throw error and exit if variable used has not been declared.
		if (variables[name] == "") {
			printf errors["variable-undeclared"], name, FNR | "cat >&2"
			exit 1
		}

		$0 = substr($0, 0, RSTART - 1) variables[name] substr($0, RSTART + RLENGTH, length($0))
	}
}

# Line printing
# -------------
#
# This block contains line-printing rules, for results generated in the above
# blocks.
#
# > Match empty line. Consecutive empty lines do not print, and are instead
# > squashed down to a single line.
if (NF == 0) {
	if ((newlines += 1) < 2) {
		print
	}

	continue
}

# > Print non-blank line, resetting the newline count, used above.
newlines = 0
print

}

# Import stack termination
# -------------------------
#
# This block contains termination rules for the import stack, as initialized in
# aforementioned blocks.
#
# When a file on the stack reaches EOF or error, the file is closed and the
# reference popped from the top of the stack. If the stack is left empty, the
# program continues to cleanup and exit, as defined in the block below.

close(imports[imports["length"]])

delete processed[imports[imports["length"]]]
imports["length"] -= 1

}

# Cleanup
# -------
#
# This block contains cleanup operations on end of execution.

exit 0

}