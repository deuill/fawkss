#!/usr/bin/awk -f
#
# Fawkss is a CSS preprocessor for people who dislike CSS preprocessors. It
# implements a subset of the SCSS syntax while remaining relatively simple.

# ------------------
# Built-in functions
# ------------------

# This block contains global helper functions, used across different rules, as
# defined below.

# Returns the index of the last occurence of a substring `s` in `str`, or -1
# if the substring was not found.
function lastindex(str, s) {
	match(str, ".*" s)
	return max(RSTART + RLENGTH - 1, -1)
}

# Finds and returns greatest between two numbers.
function max(x, y) {
	return (x > y) ? x : y
}

# Trims character class (whitespace by default) off both ends of a string.
function trim(str, chars) {
	t = (chars != "") ? chars : ":space:"
	match(str, "[" t "]*[^[" t "]]+[" t "]*")

	return substr(str, RSTART, RLENGTH)
}

# --------------
# Initialization
# --------------

# This block contains initialization logic for Fawkss.

BEGIN {
	# Error messages used across Fawkss.
	errors["unused-variable"] = "ERROR: Use of undeclared variable '%s' on line %d\n"

	# Rule definitions. Each rule corresponds to a regular expression matching
	# that rule on any given line.
	rules["comment"]           = "[ ]*//.*$"
	rules["comment-exception"] = "['\"][^//]*//[^'\"]*['\"]"

	rules["variable-name"]   = "\\$[a-zA-Z0-9_]+"
	rules["variable-define"] = "^[ ]*" rules["variable-name"] "[ ]*:"
}

# ----------------
# Rule definitions
# ----------------

# This block contains rule definitions used across Fawkss. A rule is defined as
# an exclusive match against a single line which always contines on to the next
# line. As such, rules are not composable.

# Variable definition rule.
$0 ~ rules["variable-define"] {
	# Split text in tokens.
	split($0, token, ":")

	# Get variable name and value.
	name = trim(substr(token[1], index(token[1], "$")))
	value = trim(substr(token[2], 0, lastindex(token[2], ";") - 1))

	# Assign variable to global variables table.
	variables[name] = value
	next
}

# -----------------
# Line manipulation
# -----------------

# This block contains line manipulation rules which modify lines to be printed.

# Match inline comments.
$0 ~ rules["comment"] {
	# Remove any special cases from the line.
	while (match($0, rules["comment-exception"])) {
		special[len += 1] = RSTART ":" substr($0, RSTART, RLENGTH)
		$0 = substr($0, 0, RSTART - 1) substr($0, RSTART + RLENGTH, length($0))
	}

	# Remove inline comments from line.
	while (match($0, rules["comment"])) {
		$0 = substr($0, 0, RSTART - 1) substr($0, RSTART + RLENGTH, length($0))
	}

	# Reinsert special cases in their predefined positions.
	for (i = len; i != 0; i--) {
		pos = substr(special[i], 0, index(special[i], ":") - 1)

		# Do not attempt to reinsert special case string if string has been
		# truncated to less the original position of the string.
		if (pos > length($0)) {
			continue
		}

		str = substr(special[i], index(special[i], ":") + 1, length(special[i]))
		$0 = substr($0, 0, pos - 1) str substr($0, pos, length($0))
	}

	len = 0
}

# Match variable uses.
$0 ~ rules["variable-name"] {
	# Replace each variable use with its concrete value.
	while (match($0, rules["variable-name"])) {
		name = substr($0, RSTART, RLENGTH)

		# Throw error and exit if variable used has not been declared.
		if (variables[name] == "") {
			printf errors["unused-variable"], name, NR | "cat >&2"
			exit
		}

		$0 = substr($0, 0, RSTART - 1) variables[name] substr($0, RSTART + RLENGTH, length($0))
	}
}

# --------
# Printing
# --------

# Do not print more than two consecutive newlines.
!NF {
	if ((newlines += 1) < 2) {
		print
	}

	next
}

# Print non-blank line and reset newline count.
{
	newlines = 0
	print
}